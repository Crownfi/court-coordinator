// auto-generated by C.E.W.T.
// DO NOT EDIT BY HAND!!
import { normalizeFormValues } from "@aritz-cracker/browser-utils";
export class StakingInputsRefs {
	#element: HTMLElement | ShadowRoot;
	constructor(element: HTMLElement | ShadowRoot) {
		this.#element = element;
	}
	#formStake?: HTMLFormElementKnownControls<StakingInputsFormCollection1, StakingInputsFormValues1>;
	get formStake() {
		if (this.#formStake === undefined) {
			this.#formStake = this.#element.querySelector("[cewt-ref=\"form-stake\"]:not(:scope [is] *)")!;
			this.#formStake.values = normalizeFormValues.bind(this.#formStake, this.#formStake) as any;
		}
		return this.#formStake;
	}
	#unstakedBalance?: HTMLSpanElement;
	get unstakedBalance() {
		if (this.#unstakedBalance === undefined) {
			this.#unstakedBalance = this.#element.querySelector("[cewt-ref=\"unstaked-balance\"]:not(:scope [is] *)")!;
		}
		return this.#unstakedBalance;
	}
	#stakedBalance?: HTMLSpanElement;
	get stakedBalance() {
		if (this.#stakedBalance === undefined) {
			this.#stakedBalance = this.#element.querySelector("[cewt-ref=\"staked-balance\"]:not(:scope [is] *)")!;
		}
		return this.#stakedBalance;
	}
	#buttonUnstake?: HTMLButtonElement;
	get buttonUnstake() {
		if (this.#buttonUnstake === undefined) {
			this.#buttonUnstake = this.#element.querySelector("[cewt-ref=\"button-unstake\"]:not(:scope [is] *)")!;
		}
		return this.#buttonUnstake;
	}
}
let _templateStakingInputs: HTMLTemplateElement | null = null;
function getStakingInputsTemplate(): HTMLTemplateElement {
	if (_templateStakingInputs == null) {
		 _templateStakingInputs = document.createElement("template")
		 _templateStakingInputs.innerHTML = "\n\t<h3 class=\"text-primary text-fantasy\">User shares</h3>\n\t<p>\n\t\tIn order to participate in the DAO, you must stake your votes.\n\t</p>\n\t<form cewt-ref=\"form-stake\">\n\t\t<div class=\"trade-amount-balance\">\n\t\t\tUnstaked shares: <span cewt-ref=\"unstaked-balance\"></span>\n\t\t</div>\n\t\t<label class=\"trade-amount-input\">\n\t\t\t<span>Amount to stake</span>\n\t\t\t<input type=\"number\" min=\"1\" class=\"form-control\" name=\"amount\" placeholder=\"0\">\n\t\t</label>\n\t\t<button class=\"primary small trade-execute\">Stake</button>\n\t</form>\n\n\t<div class=\"trade-amount-balance\">\n\t\tStaked shares: <span cewt-ref=\"staked-balance\"></span>\n\t</div>\n\t<div class=\"important-note\">\n\t\tYou may only unstake your voting shares after all proposals you\'ve voted on have been finalized.\n\t</div>\n\t<button cewt-ref=\"button-unstake\" class=\"primary small trade-execute\">Unstake</button>\n";
	}
	return _templateStakingInputs;
}
export class StakingInputsAutogen extends HTMLDivElement {
	readonly refs: StakingInputsRefs;
	constructor() {
		super();
		if (this.childElementCount == 0) {
			this.appendChild(
				getStakingInputsTemplate()
					.content
					.cloneNode(true)
			);
		}
		this.setAttribute("is", "staking-inputs"); // allow for easy query selecting
		this.refs = new StakingInputsRefs(this);
	}
	connectedCallback() {
		// To be overridden by child class
	}
	disconnectedCallback() {
		// To be overridden by child class
	}
	adoptedCallback() {
		// To be overridden by child class
	}
	public static registerElement() {
		customElements.define("staking-inputs", this, { extends: "div"});
	}
}
export type StakingInputsFormCollection1 = HTMLFormControlsCollection & {
	"amount": HTMLInputElement;
	namedItem(name: "amount"): HTMLInputElement;
};
export type StakingInputsFormValues1 = {
	"amount": number;
};
interface HTMLFormElementKnownControls<C extends HTMLFormControlsCollection, V> extends HTMLFormElement {
	readonly elements: C;
	values: () => V;
};
